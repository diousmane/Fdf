# üìö Guide Complet du Projet FdF

## üéØ Introduction

**FdF** (Fil de Fer = Wireframe) est un projet qui dessine des cartes 3D en 2D sur votre √©cran.

Imaginez une **carte de montagne** vue d'en haut :
- Chaque point a une **altitude** (hauteur)
- On les connecte entre eux avec des **lignes**
- On transforme √ßa pour le voir en **3D** √† l'√©cran

---

## üìÅ Structure du Projet

```
Fdf/
‚îú‚îÄ‚îÄ src/              ‚Üê CODE SOURCE (votre travail)
‚îÇ   ‚îú‚îÄ‚îÄ main.c        ‚Üê Point de d√©part du programme
‚îÇ   ‚îú‚îÄ‚îÄ parsing.c     ‚Üê Lecture du fichier .fdf
‚îÇ   ‚îú‚îÄ‚îÄ parse_utils.c ‚Üê Fonctions utilitaires pour lire
‚îÇ   ‚îú‚îÄ‚îÄ projection.c  ‚Üê Transformation 3D‚Üí2D
‚îÇ   ‚îú‚îÄ‚îÄ drawing.c     ‚Üê Dessin sur l'image
‚îÇ   ‚îú‚îÄ‚îÄ draw_line.c   ‚Üê Tra√ßage des lignes pixel par pixel
‚îÇ   ‚îî‚îÄ‚îÄ display.c     ‚Üê Cr√©ation fen√™tre + √©v√©nements
‚îú‚îÄ‚îÄ includes/
‚îÇ   ‚îî‚îÄ‚îÄ fdf.h         ‚Üê Toutes les d√©clarations (comme un sommaire)
‚îú‚îÄ‚îÄ libft/            ‚Üê Vos fonctions de base
‚îú‚îÄ‚îÄ minilibx-linux/   ‚Üê Biblioth√®que pour cr√©er fen√™tres
‚îî‚îÄ‚îÄ test_maps/        ‚Üê Fichiers de test .fdf
```

---

## üîç PARTIE 1 : Les Concepts de Base

### 1. Qu'est-ce qu'une Structure (`struct`) ?

Une structure, c'est une **bo√Æte** qui regroupe plusieurs variables ensemble.

**Exemple dans la vie** :
- Une personne a : nom, √¢ge, taille
- Au lieu de cr√©er 3 variables s√©par√©es, on cr√©e une structure "Personne"

**En code** :
```c
// Structure pour stocker une carte
typedef struct s_map
{
    int **z_matrix;      // Tableau 2D des altitudes
    int **color_matrix;  // Tableau 2D des couleurs
    int width;           // Largeur de la carte
    int height;          // Hauteur de la carte
    int z_min;           // Altitude minimale
    int z_max;           // Altitude maximale
}   t_map;
```

**Utilisation** :
```c
t_map carte;                // Cr√©e une carte vide
carte.width = 10;           // Met largeur √† 10
carte.z_matrix[0][0] = 5;   // Met altitude √† (0,0) = 5
```

### 2. Qu'est-ce qu'un Pointeur (`*`) ?

Un pointeur, c'est une **adresse en m√©moire**.

**Analogie** :
- Votre maison = variable normale
- L'adresse de votre maison sur un papier = pointeur

**En code** :
```c
t_map carte;         // Structure NORMALE (la maison)
t_map *carte;        // POINTEUR vers structure (adresse)
```

**Diff√©rence `.` vs `->`** :
```c
t_map carte;         // Pas de *
carte.width          // On utilise le POINT (.)

t_map *carte;        // Il y a un *
carte->width         // On utilise la FL√àCHE (->)
```

**Pourquoi des pointeurs ?**
- Pour **passer des structures** √† des fonctions
- Pour **modifier** la structure dans une fonction
- Pour **√©conomiser la m√©moire**

---

## üìñ PARTIE 2 : Le Fonctionnement √âtape par √âtape

### √âtape 0 : Le Fichier `.fdf`

Le fichier `.fdf` contient les altitudes de votre carte.

**Exemple** (`test_maps/42.fdf`) :
```
0 0 0
0 5 0
0 0 0
```

**Ce que √ßa signifie** :
- Ligne 1 : point √† (0,0) altitude 0, point √† (1,0) altitude 0, point √† (2,0) altitude 0
- Ligne 2 : point √† (0,1) altitude 0, point √† (1,1) altitude 5 (SOMMET!), point √† (2,1) altitude 0
- Ligne 3 : point √† (0,2) altitude 0, point √† (1,2) altitude 0, point √† (2,2) altitude 0

C'est une **petite montagne** avec un sommet au milieu !

---

### √âtape 1 : Le Programme D√©marre (`main.c`)

**Fichier** : `src/main.c`

```c
int main(int argc, char **argv)
{
    // 1. V√©rifie qu'on a donn√© un argument
    if (argc != 2)
    {
        ft_putstr_fd("Usage: ./fdf fichier.fdf\n", 2);
        return (1);
    }
    
    // 2. Lance le programme principal
    launch_fdf(argv[1]);
    
    return (0);
}
```

**Explication ligne par ligne** :

1. `int argc` = nombre d'arguments
   - `argc = 1` ‚Üí juste le nom du programme
   - `argc = 2` ‚Üí programme + fichier .fdf (‚úÖ bon !)
   - `argc = 3` ‚Üí trop d'arguments (‚ùå erreur)

2. `char **argv` = tableau de cha√Ænes de caract√®res
   - `argv[0]` = "./fdf"
   - `argv[1]` = "test_maps/42.fdf"

3. Si pas le bon nombre d'arguments ‚Üí message d'erreur et on quitte

4. Sinon ‚Üí on appelle `launch_fdf()` avec le fichier

---

### √âtape 2 : Parsing - Lecture du Fichier (`parsing.c` + `parse_utils.c`)

**Objectif** : Lire le fichier `.fdf` et remplir les tableaux

#### 2.1. Compter les Lignes (`count_lines()`)

```c
int count_lines(char *filename)
{
    int  nb_lines = 0;
    char *line;
    
    // Ouvre le fichier
    fd = open(filename, O_RDONLY);
    
    // Lit ligne par ligne
    line = get_next_line(fd);
    while (line)
    {
        nb_lines++;        // ‚Üê On compte
        free(line);        // ‚Üê On lib√®re la m√©moire
        line = get_next_line(fd);
    }
    
    close(fd);
    return nb_lines;       // ‚Üê Nombre de lignes
}
```

**Exemple** : Si le fichier a 3 lignes ‚Üí retourne `3`

#### 2.2. Compter les Colonnes (`count_columns()`)

```c
int count_columns(char *line)
{
    // Exemple: line = "10 20 30"
    char **words = ft_split(line, ' ');
    // words = ["10", "20", "30"]
    
    int nb = 0;
    while (words[nb])
        nb++;
    // nb = 3
    
    // Lib√®re la m√©moire
    free(words);
    return nb;  // ‚Üê 3
}
```

**Astuce** : `ft_split()` d√©coupe une cha√Æne par un caract√®re
- Entr√©e : `"10 20 30"` avec `' '`
- Sortie : `["10", "20", "30"]`

#### 2.3. Remplir les Tableaux (`fill_map()`)

```c
void fill_map(char *filename, t_map *map)
{
    // 1. Alloue de la m√©moire pour les tableaux
    map->z_matrix = malloc(...);      // Tableau d'altitudes
    map->color_matrix = malloc(...);   // Tableau de couleurs
    
    // 2. Ouvre le fichier
    fd = open(filename, O_RDONLY);
    
    // 3. Lit chaque ligne
    y = 0;
    while (y < map->height)
    {
        line = get_next_line(fd);
        
        // 4. D√©coupe la ligne en nombres
        numbers = ft_split(line, ' ');
        
        // 5. Remplit chaque colonne
        x = 0;
        while (x < map->width)
        {
            // Convertit "10" en nombre 10
            map->z_matrix[y][x] = ft_atoi(numbers[x]);
            map->color_matrix[y][x] = COLOR_WHITE;
            
            // Met √† jour min/max
            if (map->z_matrix[y][x] < map->z_min)
                map->z_min = map->z_matrix[y][x];
            if (map->z_matrix[y][x] > map->z_max)
                map->z_max = map->z_matrix[y][x];
            
            x++;
        }
        y++;
    }
}
```

**R√©sultat** :
- `map->z_matrix[0][0] = 0`
- `map->z_matrix[0][1] = 0`
- `map->z_matrix[1][1] = 5`  ‚Üê Le sommet !
- etc.

---

### √âtape 3 : Projection - Transformation 3D‚Üí2D (`projection.c`)

**Objectif** : Transformer les coordonn√©es de la carte en coordonn√©es √©cran

#### 3.1. Valeur Absolue (`abs_value()`)

```c
int abs_value(int n)
{
    if (n < 0)
        return (-n);  // Exemple: -5 ‚Üí 5
    return (n);       // Exemple: 5 ‚Üí 5
}
```

**Utilit√©** : Pour calculer les distances (toujours positives)

#### 3.2. Projection Isom√©trique (`project_point()`)

C'est le **truc magique** qui transforme en 3D !

```c
void project_point(t_point *pt, int z, t_window *win)
{
    int old_x = pt->x * win->zoom;      // Applique le zoom
    int old_y = pt->y * win->zoom;
    
    // Formules de projection isom√©trique
    pt->x = (old_x - old_y) * 0.866;    // 0.866 = cos(30¬∞)
    pt->y = (old_x + old_y) * 0.5 - z;  // 0.5 = sin(30¬∞)
    
    // Centre au milieu de l'√©cran
    pt->x += WIDTH / 2;
    pt->y += HEIGHT / 2;
}
```

**Explication des formules** :

1. **`(old_x - old_y) * 0.866`** :
   - C'est comme "regarder en diagonale"
   - Multiplie par 0.866 pour "aplatir"

2. **`(old_x + old_y) * 0.5 - z`** :
   - Combinaison de x et y
   - Soustrait z (altitude) pour la profondeur

3. **`+= WIDTH / 2` et `+= HEIGHT / 2`** :
   - D√©place tout au centre de l'√©cran
   - Sinon ce serait dans un coin

**R√©sultat** : Vous obtenez des coordonn√©es (x, y) pour l'√©cran !

---

### √âtape 4 : Dessin - Tracer les Lignes (`drawing.c` + `draw_line.c`)

**Objectif** : Dessiner la carte pixel par pixel

#### 4.1. Mettre un Pixel (`put_pixel()`)

```c
void put_pixel(t_window *win, int x, int y, int color)
{
    // V√©rifie que le pixel est dans la fen√™tre
    if (x >= 0 && x < WIDTH && y >= 0 && y < HEIGHT)
    {
        // Calcule o√π se trouve le pixel en m√©moire
        int position = y * win->line_length + x * (win->bits_per_pixel / 8);
        
        // √âcrit la couleur directement en m√©moire
        *(unsigned int *)(win->img_data + position) = color;
    }
}
```

**Explication** :
- `line_length` = largeur d'une ligne en octets
- `y * line_length` = saute y lignes
- `x * (bits_per_pixel / 8)` = avance de x pixels
- `*(unsigned int *)` = convertit en nombre (couleur)

#### 4.2. Algorithme de Bresenham (`draw_line.c`)

C'est un algorithme c√©l√®bre pour tracer des lignes !

**Probl√®me** : Comment tracer une ligne droite entre 2 points ?
- On ne peut dessiner que des pixels (pas de demi-pixels)

**Solution de Bresenham** :
- On avance pixel par pixel
- On d√©cide √† chaque fois : monter/descendre ou non
- Exemple : tracer ligne de (0,0) √† (10,3)

```c
void draw_line(t_window *win, t_point p1, t_point p2)
{
    // Calcule les diff√©rences
    dx = |p2.x - p1.x|;  // Distance horizontale
    dy = |p2.y - p1.y|;  // Distance verticale
    
    // Si ligne plut√¥t horizontale
    if (dx >= dy)
    {
        // Tracer horizontalement
        while (p1.x <= p2.x)
        {
            put_pixel(win, p1.x, p1.y, COLOR_WHITE);
            
            // Calcule si on doit monter
            err -= dy;
            if (err < 0)
            {
                p1.y++;      // On monte !
                err += dx;   // Ajuste
            }
            p1.x++;  // On avance toujours
        }
    }
    else
    {
        // Tracer verticalement (m√™me principe mais en Y)
    }
}
```

**Image** :
```
Point 1                Point 2
   *                      *
    \                    /
     \                  /
      \                /
       \              /
        *‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ*‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ*     
```

#### 4.3. Dessiner Toute la Carte (`draw_map()`)

```c
void draw_map(t_window *win)
{
    y = 0;
    while (y < win->map->height)
    {
        x = 0;
        while (x < win->map->width)
        {
            // 1. Prend un point de la carte
            p1.x = x;
            p1.y = y;
            
            // 2. Le projette en 2D
            project_point(&p1, win->map->z_matrix[y][x], win);
            
            // 3. Dessine les connexions vers droite et bas
            if (x < win->map->width - 1)
                // Dessine vers la droite
                draw_line(win, p1, point_droite);
            
            if (y < win->map->height - 1)
                // Dessine vers le bas
                draw_line(win, p1, point_bas);
            
            x++;
        }
        y++;
    }
}
```

**R√©sultat** : Tous les points sont connect√©s !

---

### √âtape 5 : Affichage - Cr√©ation Fen√™tre (`display.c`)

**Objectif** : Cr√©er une fen√™tre et g√©rer les √©v√©nements

#### 5.1. Initialiser MLX (`init_mlx()`)

```c
void init_mlx(t_window *win)
{
    // 1. Initialise la biblioth√®que MLX
    win->mlx = mlx_init();
    
    // 2. Cr√©e une fen√™tre 1920x1080
    win->win = mlx_new_window(win->mlx, WIDTH, HEIGHT, TITLE);
    
    // 3. Cr√©e une image (buffer) pour dessiner
    win->img = mlx_new_image(win->mlx, WIDTH, HEIGHT);
    
    // 4. R√©cup√®re l'adresse m√©moire de l'image
    win->img_data = mlx_get_data_addr(win->img, ...);
}
```

**Pourquoi une image ?**
- On dessine D'ABORD dans l'image (en m√©moire)
- Puis on AFFICHE l'image en une fois
- Plus rapide que de dessiner pixel par pixel √† l'√©cran

#### 5.2. Calculer le Zoom (`calc_zoom()`)

```c
void calc_zoom(t_window *win)
{
    // Calcule zoom pour que la carte tienne dans 80% de l'√©cran
    zoom_x = (WIDTH * 0.8) / map->width;
    zoom_y = (HEIGHT * 0.8) / map->height;
    
    // Prend le plus petit (pour que tout tienne)
    if (zoom_x < zoom_y)
        win->zoom = zoom_x;
    else
        win->zoom = zoom_y;
}
```

**Exemple** :
- Fen√™tre : 1920√ó1080
- Carte : 100√ó50
- `zoom_x = 1920*0.8 / 100 = 15.36`
- `zoom_y = 1080*0.8 / 50 = 17.28`
- ‚Üí Prend `15` (le plus petit)

#### 5.3. G√©rer les √âv√©nements (`key_press()` + `close_win()`)

```c
int key_press(int key, t_window *win)
{
    if (key == KEY_ESC)      // Si on appuie sur ESC
        close_win(win);      // Ferme le programme
    return (0);
}

int close_win(t_window *win)
{
    // Lib√®re TOUTE la m√©moire
    mlx_destroy_image(...);
    mlx_destroy_window(...);
    free_map(win->map);      // Lib√®re la carte
    free(win);               // Lib√®re la fen√™tre
    exit(0);                 // Quitte
}
```

---

## üîÑ FLUX COMPLET DU PROGRAMME

```
1. main() 
   ‚Üì
2. launch_fdf()
   ‚îú‚îÄ parse_map()        ‚Üê Lit le fichier .fdf
   ‚îÇ   ‚îú‚îÄ count_lines()
   ‚îÇ   ‚îú‚îÄ count_columns()
   ‚îÇ   ‚îî‚îÄ fill_map()
   ‚îú‚îÄ init_mlx()         ‚Üê Cr√©e fen√™tre
   ‚îú‚îÄ calc_zoom()        ‚Üê Calcule zoom
   ‚îú‚îÄ draw_map()         ‚Üê Dessine la carte
   ‚îÇ   ‚îú‚îÄ project_point()    (3D‚Üí2D)
   ‚îÇ   ‚îî‚îÄ draw_line()         (tracer lignes)
   ‚îú‚îÄ mlx_put_image_to_window()  ‚Üê Affiche
   ‚îî‚îÄ mlx_loop()          ‚Üê Attend √©v√©nements
   
3. L'utilisateur appuie ESC
   ‚Üì
4. key_press() appelle close_win()
   ‚Üì
5. close_win() lib√®re tout et exit()
```

---

## üí° Concepts Importants √† Retenir

### 1. Les Tableaux 2D (`int **`)

```c
int **z_matrix;   // ‚Üê Tableau de tableaux

// Cr√©ation :
z_matrix = malloc(sizeof(int *) * height);  // Alloue les lignes
z_matrix[0] = malloc(sizeof(int) * width);  // Alloue ligne 0
z_matrix[1] = malloc(sizeof(int) * width);  // Alloue ligne 1

// Utilisation :
z_matrix[y][x] = 10;  // Met 10 √† la position (x,y)
```

**C'est comme un tableau Excel** :
```
      x=0  x=1  x=2
y=0    0    0    0
y=1    0    5    0
y=2    0    0    0
```

### 2. Le Zoom

Le zoom, c'est un **multiplicateur** :
- `zoom = 1` ‚Üí taille normale
- `zoom = 10` ‚Üí 10 fois plus grand
- `zoom = 0.5` ‚Üí 2 fois plus petit

**Dans le code** :
```c
pt->x = x * win->zoom;  // Multiplie par le zoom
```

### 3. La Projection Isom√©trique

C'est une **vue en 3D** √† 45¬∞ depuis le coin.

**Sans projection** (vu de dessus) :
```
0 0 0
0 5 0
0 0 0
```

**Avec projection isom√©trique** (vue 3D) :
```
   0
  / \
 5   0
```

**Les formules** :
- `x_2D = (x - y) * cos(30¬∞)`  ‚Üí On "tourne"
- `y_2D = (x + y) * sin(30¬∞) - z`  ‚Üí On "penche" + altitude

---

## üé® COMMENT √áA RESSEMBLE ?

### Sans Projet :
```
Fichier : "0 5 0"
```

### Apr√®s Parsing :
```
Tableau z_matrix[3][3] :
0 0 0
0 5 0
0 0 0
```

### Apr√®s Projection Isom√©trique :
```
     *  ‚Üê point (0,1) √† altitude 5
    /|\
   / | \
  /  |  \
 *---*---*
```

### Affich√© √† l'√âcran :
Une **petite montagne 3D** en blanc sur fond noir !

---

## üõ†Ô∏è Les Fonctions de Libft Utilis√©es

| Fonction | Utilit√© | Exemple |
|----------|---------|---------|
| `ft_split(str, ' ')` | D√©coupe par espaces | `"10 20"` ‚Üí `["10", "20"]` |
| `ft_atoi(str)` | Convertit en nombre | `"42"` ‚Üí `42` |
| `get_next_line(fd)` | Lit une ligne | Lit fichier ligne par ligne |
| `ft_putstr_fd(s, 2)` | Affiche erreur | `"Error\n"` sur stderr |
| `malloc()` / `free()` | G√®re m√©moire | Alloue/lib√®re |

---

## üöÄ Pour Tester

```bash
# Compiler
make

# Lancer une carte
./fdf test_maps/42.fdf

# Appuyer sur ESC pour quitter
```

---

## ‚úÖ R√©capitulatif

1. **main.c** : Point d'entr√©e, v√©rifie arguments
2. **parsing.c** : Lit fichier ‚Üí remplit tableaux
3. **projection.c** : Transforme coordonn√©es 3D‚Üí2D
4. **drawing.c** : Dessine pixels dans l'image
5. **draw_line.c** : Trace des lignes (algorithme Bresenham)
6. **display.c** : Cr√©e fen√™tre, g√®re √©v√©nements

**Le tout utilise vos fonctions libft** (`ft_split`, `ft_atoi`, `get_next_line`) !

---

üéì **Maintenant vous comprenez comment fonctionne FdF !** üí™

